\section{Introduction}\label{sec:intro}
%
Formal hardware verification is now a well-established design technology~\cite{Seligman:2015:FV}. From its modest beginnings in the 1980s, extensive corporate and academic research in hardware verification has gone hand-in-hand with gradual but sustained industrial take-up. Examples of landmark achievements in full correctness analysis include verification of the entire execution clusters of the Core 2 Duo~\cite{Core2}  and Core i7 processors~\cite{i7} and the end-to-end ISA verification of several ARM processors~\cite{ARM}. The most prevalent methodology, assertion-based verification~\cite{Foster:2009:AAB}, is by now well supported by mature software tools from the EDA companies.

The industrial success of formal hardware verification has been advanced by decades of research into specialised data structures and algorithms~\cite{vis}, tools~\cite{Seger:2005:IEE,abc}, and methodology~\cite{MCMILLAN2000279,Aagaard:2000:MLH}. \comment{$\leftarrow$ Rajdeep to add some refs.} The most-used technology relies on back-end analysis by propositional satisfiability (SAT) solvers~\cite{Biere1999} or by modern solvers for satisfiability modulo theories (SMT)~\cite{decision_procedures, DBLP:conf/lpar/AndrausLS08,soc-keating,
DBLP:conf/mtv/SunkariCVM07,DBLP:conf/cav/Bjesse08}. Scientifically inspired and practically fruitful research into hardware verification continues today, with scalability an ever-present challenge---along with many others. 

But the past two decades have also seen an explosion in research into automated formal verfication of software~\cite{dkw2008}, with progress vivdly witnessed by the yearly `SV-COMP' competition~\cite{Beyer2017}.  Verification of industrial-scale software is now an established possibility, and commerial offerings are starting to appear. Some techniques used in software verification, such as interpolation~\cite{Interpolants,Kroening:2011:ISV}, have analogues in hardware verification. Others, such as abstract interpretation~\cite{CousotCousot77,Cousot:1996:AI}, have been largely confined to the software domain.  

In this paper, we explore the potential for hardware verification to leverage past and future progress in software verification. We translate a hardware model, articulated in Verilog at register transfer level, into a \emph{software netlist}, an ANSI-C program that faithfully reproduces the hardware in software. This opens the door to experiments with using software verification technologies, arising from contemporary program analysis research, to formal verification of hardware RTL designs. We have two aims: first, to establish baseline experimental data for verification of hardware by translation into software; second, to evaluate the effectiveness of some software verification methods---notably abstract interpretation---that have not yet been investigated for hardware.

Of course, the idea of expressing RTL designs in software has been  advocated in the past, primarily to enable faster simulation. We mention only~\cite{soc-keating}, which highlights verification-related benefits in the context of SoC design.  But we emphasize that the software models in~\cite{soc-keating} are abstractions of hardware that are usually written manually and disconnected from the `golden' RTL design  from which the chip is ultimately realized.  By contrast, our ANSI-C netlist representation is not an abstract simulation model but an exact translation of the RTL

Using this translation, we have explored formal verification of hardware using a range of 
native software analyzers.  For baseline comparison with RTL verification, we experiment with software verification technologies that employ SAT/SMT decision procedures~\cite{DBLP:conf/cav/BeyerK11,2ls,cbmc.tacas:2004,DBLP:conf/tacas/HeizmannDGLMSP16}. To 
probe the frontiers, we evaluate the use of abstraction-based software verification 
techniques---most notably abstract interpretation. Our experimental results show that a commercial abstract interpreter,  Astr{\'e}e, with manual guidance is effective for finding complex bugs 
as well as proving unbounded safety of software netlist designs. The performance of Astr{\'e}e is 
comparable to a bit-level hardware model checker ABC~\cite{abc}, and in 
in some cases Astr{\'e}e is faster for finding bugs.  On the other hand, 
Astr{\'e}e shows a high degree of imprecision on our benchmarks. We handle this 
manually, by guiding the analysis using various trace 
partitioning directives~\cite{DBLP:journals/toplas/RivalM07}.  

We make the following technical contributions in this paper.
%
\begin{enumerate}
\item We present formal verification of RTL designs in software language 
using native software analyzers.  To this end, we present an automatic 
translation of hardware circuits described in Verilog RTL into software 
program in C language using our tool \textsc{v2c}.  We call the resulting 
software program {\em software netlist}.  
%We distribute our benchmark suite containing Verilog 
%RTL designs and the equivalent C models at~\footnote{http://www.cprover.org/hardware/v2c/}. 

\item We compare formal verification of RTL designs 
using bit-level netlist and software netlist.  
%Our tool supports RTL descriptions in 1364-2005 SystemVerilog standards. 
To this end, we emperically evaluate various unbounded SAT/SMT based verification techniques, 
such as $K$-induction, Interpolation, IC3/PDR and classical abstraction-based 
techniques such as Abstract Interpretation for safety verification of RTL designs.  
%    
In particular, we compare the performance of verification 
tools that employ these techniques from Hardware Model Checking Competition 
(HWMCC)~\footnote{http://fmv.jku.at/hwmcc15/} against software verifiers from Software 
Verification Competition (SV-COMP)~\footnote{https://sv-comp.sosy-lab.org/2017/}.

\Omit {
\item Our tool also supports BDD-based model checking using a custom BDD 
package called \textsc{Mini-BDD}. To this end, we present a comparison of 
SAT/SMT based verification with the BDD-based model checker.  Our benchmarks 
are drawn from safety checking track in Hardware Model Checking Competition 
(HWMCC)~\footnote{http://fmv.jku.at/hwmcc15/} and several other open-source 
repositories.  
}

\end{enumerate}
