\section{Introduction}\label{sec:intro}
%
Formal property verification of hardware designs given in Verilog or VHDL
at the RTL description is concerned with checking the logic functionality, 
the power and security features of RTL against a formal specification. The 
specification captures the design intent and is expressed in a Property 
Specification Language (PSL), such as SystemVerilog Assertions (SVA). The 
problem above is known as \emph{Assertion Based Verification}.


Folk wisdom in the formal hardware verification community is to synthesize the 
RTL design into a bit-level netlist.  This technique uses propositional 
satisfiability solvers (SAT) to reason about the correctness of bit-blasted 
verification conditions generated from the netlist representation using a 
bounded or unbounded verification algorithm~\cite{abc,vis,andreas}.  
Most bit-level verification algorithms heavily rely on the SAT solvers 
to generate invariants or find counterexamples. 
%
This approach misses the opportunity to exploit the word-level structure of 
the RTL designs.  Formal hardware verification tools have therefore developed 
an alternative word-level flow that synthesizes the RTL design into a word-level 
netlist.  This change in the representation has enabled the use of modern solvers 
for Satisfiability Modulo Theories (SMT)~\cite{decision_procedures} in the
back-end of the tools~\cite{DBLP:conf/lpar/AndrausLS08,soc-keating,
DBLP:conf/mtv/SunkariCVM07,DBLP:conf/cav/Bjesse08}.
%
However, the performance of word-level symbolic execution engines is 
determined by the level of abstraction of the symbolic expressions and 
the power of the rewrite engine used by the SMT solvers. 
%


Unlike traditional approaches that synthesize the RTL design into a bit-level
netlist~\cite{abc,fmcad07,vis} or generate an
abstract model of the design (say C/C++ ISA or micro-architectural
models derived from RTL~\cite{satrajit}), in this paper we translate 
hardware models, articulated in Verilog at register transfer level, into 
a \emph{software netlist}. 
%
The generated model is expressed as a software program. 
% 
The natural software language for our representation is 
ANSI-C~\footnote{https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html}.  
%
Of course, the idea of expressing RTL designs in software has been 
advocated in the past, primarily to enable faster simulation; we will 
mention only~\cite{soc-keating}, which highlights property 
verification-related benefits in the context of SoC design.  
%
But we emphasize that the software models of hardware used 
in~\cite{soc-keating} are abstractions of hardware which are 
usually written \emph{manually} and are expensive to maintain---and 
often disconnected from a `golden' RTL design model from which the chip 
is ultimately realized.  By contrast, our software netlist representation 
is \emph{not} an abstract model but an \emph{exact} representation 
of the RTL.  The techniques proposed in this paper aims at a 
fully automatic property verification of the hardware RTL design via 
translation into the software netlist.  
%


In this paper, we show that the software netlist representation 
generated from the hardware RTL design allows for the application of 
verification technologies inspired by program analysis research to 
formal verification of hardware RTL designs.  
%
In particular, we present a novel property verification framework 
for hardware RTL designs in software language using native 
software analyzers.  To this end, we explore software verification 
technologies that use SAT/SMT decision procedures~\cite{DBLP:conf/cav/BeyerK11,
2ls,cbmc.tacas:2004,DBLP:conf/tacas/HeizmannDGLMSP16} as well as abstraction-based 
techniques such as abstract interpretation~\cite{CC79} for formal verification 
of RTL designs.  It is worth emphasizing that some of these techniques 
have never been applied to hardware verification.  
%


By means of experiment, we show that a commercial abstract interpreter  
Astr{\'e}e with manual guidance is effective for finding complex bugs 
as well as proving unbounded safety of the software netlist designs 
generated from the RTL circuits.  The performance of Astr{\'e}e is 
comparable to a bit-level hardware model checker \ABC~\cite{abc}.  
%
In some cases, Astr{\'e}e is faster than \ABC for finding bugs. 
%
However, Astr{\'e}e shows a high degree of imprecision on our benchmarks 
which is handled by manually guiding the analysis using various trace 
partitioning directives~\cite{DBLP:journals/toplas/RivalM07}.  
%
