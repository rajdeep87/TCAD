\section{Introduction}\label{sec:intro}
%
Formal hardware verification is now a well-established design technology~\cite{Seligman:2015:FV}. From its modest beginnings in the 1980s, extensive corporate and academic research in hardware verification has gone hand-in-hand with gradual but sustained industrial take-up. Examples of landmark achievements in full correctness analysis include verification of the entire execution clusters of the Core 2 Duo~\cite{Core2}  and Core i7 processors~\cite{i7} and the end-to-end ISA verification of several ARM processors~\cite{ARM}. The most prevalent methodology, assertion-based verification~\cite{Foster:2009:AAB}, is by now well supported by mature software tools from the EDA companies.

The industrial success of formal hardware verification has been advanced by decades of research into specialised data structures and algorithms~\cite{ic3,fmcad2000,ken,biere,STE}, tools~\cite{Seger:2005:IEE,abc,ebmc,vis,cadence,synopsysfv}, and methodology~\cite{MCMILLAN2000279,Aagaard:2000:MLH,uclid,word-term,word-bmc,DBLP:conf/lpar/AndrausLS08}.  The most-used technology relies on back-end analysis by propositional satisfiability (SAT) solvers~\cite{Biere1999} or by modern solvers for satisfiability modulo theories (SMT)~\cite{decision_procedures, DBLP:conf/lpar/AndrausLS08,soc-keating,
DBLP:conf/mtv/SunkariCVM07,DBLP:conf/cav/Bjesse08}. Scientifically inspired and practically fruitful research into hardware verification continues today, with scalability an ever-present challenge---along with many others. 

But the past two decades have also seen an explosion in research into automated formal verfication of software~\cite{dkw2008}, with progress vivdly witnessed by the yearly `SV-COMP' competition~\cite{Beyer2017}.  Verification of industrial-scale software is now an established possibility, and commerial offerings are starting to appear. Some techniques used in software verification, such as interpolation~\cite{Interpolants,Kroening:2011:ISV}, have analogues in hardware verification. Others, such as abstract interpretation~\cite{CousotCousot77,Cousot:1996:AI}, have been largely confined to the software domain.  

In this paper, we explore the potential for hardware verification to leverage past and future progress in automated software verification. We translate a hardware model, articulated in Verilog at register transfer level, into a \emph{software netlist}, an ANSI-C program that faithfully reproduces the hardware in software. This opens the door to experiments with using software verification technologies, arising from contemporary program analysis research, to formal verification of hardware RTL designs. We have two aims: first, to establish baseline experimental data for verification of hardware by translation into software; second, to evaluate the effectiveness of some software verification methods---notably abstract interpretation---that have not yet been investigated for hardware.

Of course, the idea of expressing RTL designs in software has been  advocated in the past, primarily to enable faster simulation. We mention only~\cite{soc-keating}, which highlights verification-related benefits in the context of SoC design.  But we emphasize that the software models in~\cite{soc-keating} are abstractions of hardware that are usually written manually and disconnected from the `golden' RTL design  from which the chip is ultimately realized.  By contrast, our ANSI-C netlist representation is not an abstract simulation model but an exact translation of the RTL design.

Using this translation, we have explored formal verification of hardware using a range of 
native software analyzers.  For baseline comparison with RTL verification, we experiment with software verification technologies that employ SAT/SMT decision procedures~\cite{DBLP:conf/cav/BeyerK11,2ls,cbmc.tacas:2004,DBLP:conf/tacas/HeizmannDGLMSP16}. To 
probe the frontiers, we evaluate the use of abstraction-based software verification 
techniques---most notably abstract interpretation. Our experimental results show that a commercial abstract interpreter,  Astr{\'e}e, with manual guidance is effective for finding complex bugs 
as well as proving unbounded safety of software netlist designs. The performance of Astr{\'e}e is 
comparable to a bit-level hardware model checker ABC~\cite{abc}, and in 
in some cases Astr{\'e}e is faster for finding bugs.  On the other hand, 
Astr{\'e}e shows a high degree of imprecision on our benchmarks. We handle this 
manually, by guiding the analysis using various trace 
partitioning directives~\cite{DBLP:journals/toplas/RivalM07}.  

Our two main technical contributions are the following:
%
\begin{itemize}
\item We present an automatic translation of hardware circuits described in Verilog RTL into software 
programs in C, which we call \textit{software netlists}.  We have implemented this in a tool called V2C.  

\item We report an empirical evaluation and comparison of hardware verification using native RTL verification tools and contemporary software analysis tools, via our translation into software netlists. 
We experiment with a range of unbounded SAT/SMT based verification techniques, 
such as $K$-induction, Interpolation, and IC3/PDR. We also explore classical abstraction-based 
software verification, most notably abstract interpretation.
\end{itemize}

\noindent To ensure our results are openly accessible and can be independently validated, our experiments compare the performance of verification tools drawn from  the Hardware Model Checking Competition (HWMCC)~\footnote{http://fmv.jku.at/hwmcc15/} against software verifiers from the Software Verification Competition (SV-COMP)~\footnote{https://sv-comp.sosy-lab.org/2017/}.
