\section{Related Work}~\label{related_work}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%      Bit-level Verification Literature
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     Word-level Verification Literature
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%      Software verification Literature
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The technology transfer between the hardware and software verification community 
over the past two decades have demonstrated significant drive in development of 
new verification algorithms in either field. 
% 
In 1986, Clarke et al.~\cite{clarke86} proposed model checking for finite state 
concurrent systems. Later, McMillan et. al.~\cite{mcmillan96} introduced symbolic 
model checking in 1996.  Biere et al.~\cite{tacas99} introduced symbolic model 
checking without BDDs in 1999.
%
Graf et al.~\cite{cav97} proposed a technique based on predicate abstraction.
Later, Clarke et. al.~\cite{cav2000} used Counterexample guided Abstraction Refinement 
(CEGAR) in SMV tool for verifying Fujitsu IP core.  
Kroening et. al.~\cite{DBLP:conf/tacas/JainKSC07} used CEGAR to 
verify hardware designs written in Verilog RTL.  Subsequently, predicate 
abstraction is used for verifying device drivers in C program by Ball et al.~\cite{pldi01}.  
This lead to the SLAM project by Ball et. al.~\cite{popl02} in 2002.
%
In 2000, St$\mathring{\text{a}}$lmarck et al.~\cite{fmcad2000} introduced a technique 
to check safety properties using Induction and SAT solver.  Subsequnetly, induction 
based approaches are used for automatic analysis of scratch-pad memory code for heterogeneous
multicore processors by Donaldson et. al.~\cite{tacas10}, 2010 and for software 
verification using k-induction by Donaldson et al.~\cite{sas2011} in 2011.
% 
In 2003, McMillan et al.~\cite{cav03} introduced Interpolation and SAT-based model 
checking for verifying commercial microprocessor. Subsequently, Intrpolation is used 
for software verification by McMillan et. al.~\cite{cav06} in 2006 and by 
Kroening et al.~\cite{DBLP:conf/cav/KroeningW11}, in 2011.
%
In 2007, Bradley et. al.~\cite{fmcad07} introduced safety checking by inductive 
generalizations of counterexample to induction, a technique commonly known 
as IC3. Subsequnetly, IC3 is used for software model checking by 
Cimatti et al.~\cite{cav12ic3} in 2012.
%
Thus, techniques like predicate abstraction, 
IC3 or Property Directed Reachability (PDR), $k$-induction, and 
interpolation-based approaches have all made their way from the hardware 
to the software domain; but path-wise symbolic execution and abstract 
interpretation have been primarily used for software verification.
%
A survey of bounded and unbounded SAT-based hardware model checking techniques 
is presented in~\cite{DBLP:conf/charme/AmlaDKKM05}.
%

\Omit{
A survey of bounded and unbounded SAT-based hardware model checking techniques 
is presented in~\cite{charme05}.
Table~\ref{timeline} provides a summary of technology transfer between the 
hardware verification community and software verification community over the past 
two decades.  The table provides the reference to the very first technique proposed 
in the literature in either community but there are subsequent works that
follows up from these.  For example, techniques like predicate abstraction, 
IC3 or Property Directed Reachability (PDR), $k$-induction, and 
interpolation-based approaches have all made their way from the hardware 
to the software domain; but path-wise symbolic execution and abstract 
interpretation have been primarily used for software verification.
%
\begin{table}[]
\centering
\scriptsize
\caption{Technology transfer between the Hardware and Software Verification Community}
\label{timeline}
\begin{tabular}{p{0.2\textwidth}|p{0.2\textwidth}}
\toprule
  Hardware Verification & Software Verification \\
  \midrule
  \begin{itemize}
  \item Symbolic Model Checking without BDDs 
    by Biere et. al.~\cite{tacas99}, 1999
\end{itemize}
 & 
 \begin{itemize}
  \item Model Checking for finite state concurrent systems by Clarke et
    al.~\cite{clarke86}, 1986
  \item Symbolic Model Checking by McMillan et. al.~\cite{mcmillan96}, 1996
\end{itemize} \\ \hline

 \begin{itemize}
 \item Predicate Abstraction by Graf et. al.~\cite{cav97}, 1997
 \item CEGAR in SMV for verifying Fujitsu IP core by Clarke et.
   al.~\cite{cav2000}, 2000 
 %\item CEGAR for Verilog by Kroening et. al.~\cite{tacas07}, 2007
 \end{itemize}
  &
  \begin{itemize}
    \item Predicate Abstraction for C program by Ball et. al.~\cite{pldi01},
      2001
    \item SLAM project by Ball et. al.~\cite{popl02}, 2002
  \end{itemize} \\ \hline
 
  \begin{itemize}
    \item Checking safety properties using Induction and SAT solver by
      St$\mathring{\text{a}}$lmarck et. al.~\cite{fmcad2000}, 2000
   \end{itemize}
   & 
   \begin{itemize}
     \item Automatic analysis of scratch-pad memory code for heterogeneous
       multicore processors by Donaldson et. al.~\cite{tacas10}, 2010
     \item Software verification using k-induction by Donaldson et.
       al.~\cite{sas2011}, 2011
   \end{itemize} \\ \hline
   
   \begin{itemize}
     \item Interpolation and SAT-based model checking for verifying commercial
       microprocessor by McMillan et. al.~\cite{cav03}, 2003
   \end{itemize}
   & 
   \begin{itemize}
     \item Lazy abstraction with interpolants by McMillan et. al.~\cite{cav06}, 2006
     \item Interpolation based software verification with Wolverine by Kroening
       et. al.~\cite{cav11}, 2011
   \end{itemize} \\ \hline
   
   \begin{itemize}
     \item Checking safety by inductive generalizations of counterexample to
       induction by Bradley et. al.~\cite{fmcad07}, 2007
   \end{itemize}
   &
   \begin{itemize}
    \item Software Model Checking via IC3 by Cimatti et. al.~\cite{cav12ic3}, 2012
   \end{itemize} \\ \hline
\bottomrule
\end{tabular}
\end{table}
%
}
